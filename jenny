#!/usr/bin/env groovy

@Grab('org.yaml:snakeyaml:1.17')

// find where jenny is installed
File scriptFile = new File(getClass().protectionDomain.codeSource.location.path)
Class NodeItem = new GroovyClassLoader(getClass().getClassLoader()).parseClass(new File(scriptFile.parent, "NodeItem.groovy"));

// -------------------------------------------------------------------
// Parse the CLI options.
// -------------------------------------------------------------------
def cli = new CliBuilder(usage: "jenny [options]")
cli.f(longOpt: "file", args: 1, argName: "file", "path to Jenkinsfile")
cli.l(longOpt: "lib", args: -2, argName: "lib", "path to the library to load")
cli.p(longOpt: "param", args: -2, argName: "property=value", valueSeparator:'=', "parameter to override")
cli.s(longOpt: "skip", args: -2, argName: "id", "stage/parallel/node blocks to skip by ID")
cli.o(longOpt: "only", args: -2, argName: "id", "stage/parallel/node blocks to run by ID (includes ancestors)")
cli.rf(longOpt: "resumeFrom", args: 1, argName: "id", "stage/parallel/node blocks to continue from")
cli.sa(longOpt: "skipAfter", args: 1, argName: "id", "stage/parallel/node blocks to skiped when reached (inclusive)")
cli.i(longOpt: "info", "show information on the current jenkinsfile, including ids")
cli.h(longOpt: "help", "show this message")

options = cli.parse(args)

if (options.h) {
    cli.usage();
    return;
}

// -------------------------------------------------------------------
// Start the execution.
// -------------------------------------------------------------------
print """>    _
>   (_) ___ _ __  _ __  _   _
>   | |/ _ \\ '_ \\| '_ \\| | | |
>   | |  __/ | | | | | | |_| |
>  _/ |\\___|_| |_|_| |_|\\__, |
> |__/                  |___/
> console jenkins runner
> 
"""

// -------------------------------------------------------------------
// Load the core libraries (config, lib loading)
// -------------------------------------------------------------------
new File(scriptFile.parent, "lib").listFiles().each {
    evaluate(it)
}

jennyGlobalConfigFolder = "${System.getenv('HOME')}/.jenny"

jennyGlobal = [:]

/**
 * Execute a build for a jenkinsfile. This uses also the parent context
 * when calling nested builds run.
 */
jennyRun = { runConfig ->
    // -------------------------------------------------------------------
    // Read the configuration for the current project.
    // -------------------------------------------------------------------
    def jennyConfig = ["libs":[], "execute":[:], "projects":[:]]

    loadConfigFile(jennyConfig, "${jennyGlobalConfigFolder}/config")
    loadConfigFile(jennyConfig, ".jenny/config")

    if (runConfig.topProject) {
        loadCommandLineOptions(jennyConfig, options)
    }

    // -------------------------------------------------------------------
    // Prepare the execution context.
    // -------------------------------------------------------------------
    def binding = new Binding()
    binding._global = binding
    binding._jennyConfig = jennyConfig
    binding._jennyRun = jennyRun
    binding._jennyGlobal = jennyGlobal

    binding.NodeItem = NodeItem

    def shell = new GroovyShell(binding)

    // -------------------------------------------------------------------
    // Create the workspace
    // -------------------------------------------------------------------
    // FIXME: generate the workspace per project
    def workspaceLocation = new File("/tmp/.jenny/workspace/")
    workspaceLocation.deleteDir()
    workspaceLocation.mkdir()
    // needed for credentials
    jennyConfig.jennyGlobalConfigFolder = jennyGlobalConfigFolder
    // needed for credentials/checkout
    jennyConfig.projectFolder = new File(new File(runConfig.projectFolder ?: ".").canonicalPath)
    // workspaceFolder is needed for pwd
    jennyConfig.workspaceFolder = workspaceLocation

    // -------------------------------------------------------------------
    // Load the default suport functions
    // -------------------------------------------------------------------
    // jenny can run in two modes:
    // 1. is to actually execute things,
    // 2. is to just provide information to the user 
    //    on what will be executed, and provide the IDs

    // load all the support files.
    new File(scriptFile.parent, "common").listFiles().each {
        shell.evaluate(it)
    }

    new File(scriptFile.parent, options.info ? "info" : "support").listFiles().each {
        shell.evaluate(it)
    }

    // -------------------------------------------------------------------
    // Load the external libraries
    // -------------------------------------------------------------------
    if (options.info) {
        loadInfoLibraries(shell, binding)
    } else {
        loadLibraries(shell, binding)
    }

    // -------------------------------------------------------------------
    // Override parameters
    // -------------------------------------------------------------------
    if (jennyConfig.params) {
        binding._definedParameters.addNested(jennyConfig.params)
    }

    // this will run the given jenkinsfile
    def jenkinsFile = new File(jennyConfig.projectFolder,
                               runConfig.jenkinsFile ?: "Jenkinsfile")

    if (!jenkinsFile.exists()) {
        throw new IllegalArgumentException("File ${jenkinsFile.canonicalPath} does not exists.")
    }

    // add the root node.
    NodeItem.runningItems.push(NodeItem.newInstance(baseId: null))

    shell.evaluate(jenkinsFile)
}

jennyRun([
    projectFolder: ".",
    jenkinsFile: (options.file ?: "Jenkinsfile"),
    topProject: true
])
